{"ast":null,"code":"import { call, put, race, take } from \"redux-saga/effects\";\nimport { delay } from \"redux-saga\";\nimport { markRequestPending, markRequestSuccess, markRequestFailure, markRequestCancelled, invokeCallback } from \"../actions/common\";\nimport { API_TIMEOUT } from \"../constants/api\";\nimport { setAuthState, removeLoggedUser } from \"../actions/auth\";\nexport const rejectErrors = res => {\n  const {\n    data\n  } = res.data;\n\n  if (!data) {\n    return Promise.reject({\n      message: res.data.message\n    });\n  }\n};\nexport const createRequestSaga = ({\n  request,\n  key,\n  success,\n  failure,\n  functionSuccess,\n  functionFailure,\n  timeout = API_TIMEOUT,\n  cancel,\n  cancelled\n}) => function* (action) {\n  let args = action.args || [];\n  console.log(args); // Kiểm tra xem có callback function ở action hay không\n\n  const callback = typeof args[args.length - 1] === \"function\" ? args[args.length - 1] : null;\n\n  if (callback) {\n    args = args.slice(0, -1);\n  }\n\n  let ret = null;\n  let err = null; // Kiểm tra xem request có phải là function hay không\n\n  const requestKey = typeof key === \"function\" ? key(...args) : key; // put vào action pending để chờ dữ liệu\n\n  yield put(markRequestPending(requestKey)); // bắt đầu gọi dữ liệu tử server về\n\n  try {\n    if (!request) {\n      throw new Error(\"Không tìm thấy API\");\n    } // yield call nhận vào 2 tham số, tham số thứ 2 là 1 mảng dữ liệu\n\n\n    const invokeRequest = async () => {\n      const chainRequest = request.apply(request, args);\n      const response = await chainRequest;\n      console.log(response);\n      if (response.data.code >= 200 && response.data.code < 300) return response.data;else return rejectErrors(response);\n    };\n\n    const raceOptions = {\n      data: call(invokeRequest),\n      isTimeout: delay(timeout)\n    };\n\n    if (cancel) {\n      raceOptions.cancelRet = take(cancel);\n    }\n\n    const {\n      data,\n      isTimeout,\n      cancelRet\n    } = yield race(raceOptions);\n    console.log(data);\n\n    if (isTimeout) {\n      throw new Error(`Api method is timeout after ${timeout} ms!!!`);\n    } else if (cancelRet) {\n      // callback on success\n      if (cancelled) {\n        for (const actionCreator of cancelled) {\n          yield put(actionCreator(cancelRet, action));\n        }\n      } // mark cancelled request\n\n\n      yield put(markRequestCancelled(cancelRet, requestKey));\n    } else {\n      if (success) {\n        for (const actionCreator of success) {\n          yield put(actionCreator(data, action));\n        }\n      }\n\n      if (functionSuccess) {\n        for (const actionCreator of functionSuccess) {\n          actionCreator(data);\n        }\n      }\n\n      yield put(markRequestSuccess(requestKey));\n      ret = data;\n    }\n  } catch (reason) {\n    if (reason.code === 401) {\n      yield put(removeLoggedUser());\n      yield put(setAuthState(false));\n    }\n\n    if (failure) {\n      for (const actionCreator of failure) {\n        yield put(actionCreator(reason, action));\n      }\n    }\n\n    if (functionFailure) {\n      for (const actionCreator of functionFailure) {\n        actionCreator(reason);\n      }\n    }\n\n    yield put(markRequestFailure(requestKey, reason));\n    err = reason;\n  } finally {\n    if (callback) {\n      // gọi lại callback và chuyển vào action invokeCallback trong action này hàm\n      // callback được gọi và thực thi\n      // ret chứa dữ liệu nếu gọi API thành công và truyền ngược lại cho\n      // hàm gọi action đó\n      yield put(invokeCallback(callback, err, ret));\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/vuhon/Desktop/dgtb_user/src/redux/sagas/common.js"],"names":["call","put","race","take","delay","markRequestPending","markRequestSuccess","markRequestFailure","markRequestCancelled","invokeCallback","API_TIMEOUT","setAuthState","removeLoggedUser","rejectErrors","res","data","Promise","reject","message","createRequestSaga","request","key","success","failure","functionSuccess","functionFailure","timeout","cancel","cancelled","action","args","console","log","callback","length","slice","ret","err","requestKey","Error","invokeRequest","chainRequest","apply","response","code","raceOptions","isTimeout","cancelRet","actionCreator","reason"],"mappings":"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","sourcesContent":["import { call, put, race, take } from \"redux-saga/effects\";\r\nimport { delay } from \"redux-saga\";\r\nimport {\r\n\tmarkRequestPending,\r\n\tmarkRequestSuccess,\r\n\tmarkRequestFailure,\r\n\tmarkRequestCancelled,\r\n\tinvokeCallback,\r\n} from \"../actions/common\";\r\nimport { API_TIMEOUT } from \"../constants/api\";\r\nimport { setAuthState, removeLoggedUser } from \"../actions/auth\";\r\nexport const rejectErrors = (res) => {\r\n\tconst { data } = res.data;\r\n\tif (!data) {\r\n\t\treturn Promise.reject({\r\n\t\t\tmessage: res.data.message,\r\n\t\t});\r\n\t}\r\n};\r\n\r\nexport const createRequestSaga = ({\r\n\trequest,\r\n\tkey,\r\n\tsuccess,\r\n\tfailure,\r\n\tfunctionSuccess,\r\n\tfunctionFailure,\r\n\ttimeout = API_TIMEOUT,\r\n\tcancel,\r\n\tcancelled,\r\n}) =>\r\n\tfunction* (action) {\r\n\t\tlet args = action.args || [];\r\n\t\tconsole.log(args);\r\n\t\t// Kiểm tra xem có callback function ở action hay không\r\n\t\tconst callback =\r\n\t\t\ttypeof args[args.length - 1] === \"function\"\r\n\t\t\t\t? args[args.length - 1]\r\n\t\t\t\t: null;\r\n\t\tif (callback) {\r\n\t\t\targs = args.slice(0, -1);\r\n\t\t}\r\n\t\tlet ret = null;\r\n\t\tlet err = null;\r\n\t\t// Kiểm tra xem request có phải là function hay không\r\n\t\tconst requestKey = typeof key === \"function\" ? key(...args) : key;\r\n\t\t// put vào action pending để chờ dữ liệu\r\n\t\tyield put(markRequestPending(requestKey));\r\n\t\t// bắt đầu gọi dữ liệu tử server về\r\n\t\ttry {\r\n\t\t\tif (!request) {\r\n\t\t\t\tthrow new Error(\"Không tìm thấy API\");\r\n\t\t\t}\r\n\t\t\t// yield call nhận vào 2 tham số, tham số thứ 2 là 1 mảng dữ liệu\r\n\t\t\tconst invokeRequest = async () => {\r\n\t\t\t\tconst chainRequest = request.apply(request, args);\r\n\t\t\t\tconst response = await chainRequest;\r\n\t\t\t\tconsole.log(response);\r\n\t\t\t\tif (response.data.code >= 200 && response.data.code < 300)\r\n\t\t\t\t\treturn response.data;\r\n\t\t\t\telse return rejectErrors(response);\r\n\t\t\t};\r\n\t\t\tconst raceOptions = {\r\n\t\t\t\tdata: call(invokeRequest),\r\n\t\t\t\tisTimeout: delay(timeout),\r\n\t\t\t};\r\n\t\t\tif (cancel) {\r\n\t\t\t\traceOptions.cancelRet = take(cancel);\r\n\t\t\t}\r\n\t\t\tconst { data, isTimeout, cancelRet } = yield race(raceOptions);\r\n\t\t\tconsole.log(data);\r\n\t\t\tif (isTimeout) {\r\n\t\t\t\tthrow new Error(`Api method is timeout after ${timeout} ms!!!`);\r\n\t\t\t} else if (cancelRet) {\r\n\t\t\t\t// callback on success\r\n\t\t\t\tif (cancelled) {\r\n\t\t\t\t\tfor (const actionCreator of cancelled) {\r\n\t\t\t\t\t\tyield put(actionCreator(cancelRet, action));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// mark cancelled request\r\n\t\t\t\tyield put(markRequestCancelled(cancelRet, requestKey));\r\n\t\t\t} else {\r\n\t\t\t\tif (success) {\r\n\t\t\t\t\tfor (const actionCreator of success) {\r\n\t\t\t\t\t\tyield put(actionCreator(data, action));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (functionSuccess) {\r\n\t\t\t\t\tfor (const actionCreator of functionSuccess) {\r\n\t\t\t\t\t\tactionCreator(data);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tyield put(markRequestSuccess(requestKey));\r\n\t\t\t\tret = data;\r\n\t\t\t}\r\n\t\t} catch (reason) {\r\n\t\t\tif (reason.code === 401) {\r\n\t\t\t\tyield put(removeLoggedUser());\r\n\t\t\t\tyield put(setAuthState(false));\r\n\t\t\t}\r\n\t\t\tif (failure) {\r\n\t\t\t\tfor (const actionCreator of failure) {\r\n\t\t\t\t\tyield put(actionCreator(reason, action));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (functionFailure) {\r\n\t\t\t\tfor (const actionCreator of functionFailure) {\r\n\t\t\t\t\tactionCreator(reason);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tyield put(markRequestFailure(requestKey, reason));\r\n\t\t\terr = reason;\r\n\t\t} finally {\r\n\t\t\tif (callback) {\r\n\t\t\t\t// gọi lại callback và chuyển vào action invokeCallback trong action này hàm\r\n\t\t\t\t// callback được gọi và thực thi\r\n\t\t\t\t// ret chứa dữ liệu nếu gọi API thành công và truyền ngược lại cho\r\n\t\t\t\t// hàm gọi action đó\r\n\t\t\t\tyield put(invokeCallback(callback, err, ret));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n"]},"metadata":{},"sourceType":"module"}